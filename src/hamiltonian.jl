using BitBasis
using ExponentialUtilities
export to_matrix, RydbergHamiltonian

struct RydbergHamiltonian
    C::Float64
    Ω::Vector{Float64}
    ϕ::Vector{Float64}
    Δ::Vector{Float64}
    atoms::AtomPosition
end

n_atoms(h::RydbergHamiltonian) = length(h.atoms)

function subspace(n::Int, mis::Vector)
    it = map(mis) do each
        fixed_points = setdiff(1:n, each)
        itercontrol(n, fixed_points, zero(fixed_points))
    end
    return unique(Iterators.flatten(it))
end

function count_ones(n::Integer)
    count = zero(n)
    while !iszero(n)
        n = n & (n - 1)
        count += 1
    end
    return count
end

function to_matrix(graph, Ω, ϕ, Δ)
    cg = complement(graph)
    mis = maximal_cliques(cg)
    n = nv(graph)
    subspace_v = subspace(n, mis)
    m = length(subspace_v)
    H = zeros(ComplexF64, m, m)

    for (i, lhs) in enumerate(subspace_v)
        # sum sigma_z
        sigma_z = 0.0
        for k in 1:n
            if readbit(lhs, k) == 1
                sigma_z -= Δ[k]
            else
                sigma_z += Δ[k]
            end
        end
        H[i, i] = sigma_z

        sigma_x = 0.0
        for k in 1:n
            each_k = readbit(lhs, k)
            rhs = flip(lhs, 1 << (k - 1))
            # TODO: optimize this part by reusing node id
            # generated by creating subspace
            if rhs in subspace_v
                j = findfirst(isequal(rhs), subspace_v)
                if each_k == 0
                    H[i, j] = Ω[k] * exp(im * ϕ[k])
                else
                    H[i, j] = Ω[k] * exp(-im * ϕ[k])
                end
            end
        end
    end
    return Hermitian(H)
end

function to_matrix(h::RydbergHamiltonian)
    g = unit_disk_graph(h.atoms)
    return to_matrix(g, h.Ω, h.ϕ, h.Δ)
end

function timestep!(st::Vector, h::RydbergHamiltonian, t::Float64, dt::Float64)
    H = to_matrix(h)
    for _ in 0:dt:t
        st = expv(dt, H, st)
    end
    return st
end
