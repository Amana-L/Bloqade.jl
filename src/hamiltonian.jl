using BitBasis
export to_matrix, RydbergHamiltonian

struct RydbergHamiltonian
    C::Float64
    Ω::Vector{Float64}
    ϕ::Vector{Float64}
    Δ::Vector{Float64}
    atoms::AtomPosition
end

n_atoms(h::RydbergHamiltonian) = length(h.atoms)

function subspace(n::Int, mis::Vector)
    it = map(mis) do each
        fixed_points = setdiff(1:n, each)
        itercontrol(n, fixed_points, zero(fixed_points))
    end
    return unique(Iterators.flatten(it))
end

function count_ones(n::Integer)
    count = zero(n)
    while !iszero(n)
        n = n & (n - 1)
        count += 1
    end
    return count
end

function to_matrix(h::RydbergHamiltonian)
    g = unit_disk_graph(h.atoms)
    cg = complement(g)
    mis = maximal_cliques(cg)
    n = n_atoms(h)
    subspace_v = subspace(n, mis)
    m = length(subspace_v)
    H = zeros(Float64, m, m)
    for (i, lhs) in enumerate(subspace_v)
        # sum sigma_z
        sigma_z = 0.0
        for k in 1:n
            if readbit(lhs, k) == 1
                sigma_z -= h.Δ[k]
            else
                sigma_z += h.Δ[k]
            end
        end
        H[i, i] = sigma_z

        sigma_x = 0.0
        for k in 1:n
            each_k = readbit(each, k)
            rhs = flip(lhs, 1 << (k - 1))
            # TODO: optimize this part by reusing node id
            # generated by creating subspace
            if rhs in subspace_v
                if each_k == 0
                    j = findfirst(isequal(rhs), subspace_v)
                    H[i, j] = h.Ω[k] * exp(im * h.ϕ[k])
                else
                    H[i, j] = h.Ω[k] * exp(-im * h.ϕ[k])
                end
            end
        end
    end
    return H
end
